import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.api.InvalidUserDataException
import org.gradle.api.internal.file.FileResolver
import org.gradle.api.internal.file.copy.CopyAction
import org.gradle.api.internal.file.copy.CopySpecInternal
import org.gradle.api.internal.file.copy.DestinationRootCopySpec
import org.gradle.api.internal.file.copy.FileCopyAction
import org.gradle.internal.reflect.Instantiator

import java.util.concurrent.Callable;

plugins {
  id 'io.codearte.nexus-staging' version '0.11.0'
  id 'net.researchgate.release' version '2.6.0'
}

apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'jacoco'
apply plugin: 'signing'

compileJava.enabled = false
processResources.enabled = false
classes.enabled = false
jar.enabled = false

afterReleaseBuild.dependsOn uploadArchives

group = 'com.nordstrom.ui-tools'
description = 'Selenium Foundation'

if (!project.hasProperty('profile')) {
  ext.profile = 'selenium2'
} else {
  assert ['selenium2', 'selenium3'].contains(profile)
}

def archiveVer = null
def verBits = project.version.split('-')
def seleniumApi = 's' + profile.charAt(8)
if (verBits.length > 1) {
  if (verBits[1].equals(seleniumApi)) {
    archiveVer = project.version
  } else {
    archiveVer = verBits[0] + '-' + seleniumApi + '-' + verBits[1]
  }
} else {
  archiveVer = verBits[0] + '-' + seleniumApi
}

project.version = archiveVer
  
def archiveBase = rootProject.name + '-' + archiveVer
def pomSourceName = "pom.xml"
def pomTargetName = archiveBase + ".pom"
def doPomCopy = true
def buildRoot = null
def libsDir = null

switch ("${profile}") {
case "selenium2":
  buildRoot = file('build-s2')
  libsDir = new File(buildRoot, 'libs')
  break
case "selenium3":
  buildRoot = file('build-s3')
  libsDir = new File(buildRoot, 'libs')
  break
}
  
gradle.taskGraph.whenReady { taskGraph ->
  if (!taskGraph.hasTask(clean)) {
    def targetFile = new File(libsDir, pomTargetName)
    if (targetFile.exists()) {
      def sourceFile = file(pomSourceName)
      def sourceTime = sourceFile.lastModified()
      def targetTime = targetFile.lastModified()
      if (sourceTime < targetTime) {
        doPomCopy = false
      }
    }
  }
}

sourceSets {
  selenium2 {
    java {
      srcDirs = [ 'src/main/java', 'src/main/java-s2' ]
      outputDir = new File(buildRoot, 'classes')
    }
    resources {
      srcDirs = [ 'src/main/resources', 'src/main/resources-s2' ]
    }
    compileClasspath = sourceSets.main.output + configurations.selenium2Compile
    runtimeClasspath = output + compileClasspath + configurations.selenium2Runtime
  }
  selenium3 {
    java {
      srcDirs = [ 'src/main/java', 'src/main/java-s3' ]
      outputDir = new File(buildRoot, 'classes')
    }
    resources {
      srcDirs = [ 'src/main/resources', 'src/main/resources-s3' ]
    }
    compileClasspath = sourceSets.main.output + configurations.selenium3Compile
    runtimeClasspath = output + compileClasspath + configurations.selenium3Runtime
  }
  test {
    java {
      outputDir = new File(buildRoot, 'test-classes')
    }
    compileClasspath += sourceSets["${profile}"].output
    runtimeClasspath += sourceSets["${profile}"].output
  }
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

jacoco {
  toolVersion = '0.7.9'
  reportsDir = file("${buildDir}/customJacocoReportDir")
}

jacocoTestReport {
  reports {
    xml.enabled false
    csv.enabled false
    html.destination file("${buildDir}/jacocoHtml")
  }
}

task("${profile}Javadoc", type: Javadoc) {
  group 'Documentation'
  description "Generates Javadoc API documentation for the '${profile}' source code."
  
  source = sourceSets["${profile}"].allJava
  classpath = configurations.compile + configurations["${profile}Compile"]
}

task pomCopy(type: PomCopy) {
  group 'Build'
  description 'Copies and filters the POM file for the active profile.'
  
  onlyIf { doPomCopy }

  def tokens = [projectVersion: archiveVer, projectTimestamp: Long.valueOf(System.currentTimeMillis()).toString()]
  
  destinationDir = libsDir
  archiveName = pomTargetName
  
  from '.'
  include pomSourceName
  rename(/.*/, pomTargetName)
  into destinationDir
  filter(ReplaceTokens, tokens: tokens)
  inputs.properties(tokens)
}

task("${profile}Jar", type: Jar) {
  group 'Build'
  description "Assembles a jar archive containing the '${profile}' classes, POM and Maven properties."
  
  def destPath = "META-INF/maven/${project.group}/${rootProject.name}"
  def tokens = [projectVersion: archiveVer, projectTimestamp: Long.valueOf(System.currentTimeMillis()).toString()]
  
  from(sourceSets["${profile}"].output) { }
  from('.') {
    include("${profile}-pom.xml")
    rename(/.*/, 'pom.xml')
    into(destPath)
    filter(ReplaceTokens, tokens: tokens)
  }
  from('.') {
    include('pom.properties')
    into(destPath)
    filter(ReplaceTokens, tokens: tokens)
  }
  archiveName = archiveBase + '.jar'
  destinationDir = libsDir
}

clean {
  delete buildRoot
}

task("${profile}SourcesJar", type: Jar) {
  group 'Build'
  description "Assembles a jar archive containing the '${profile}' source files."
  
  classifier = 'sources'
  from sourceSets["${profile}"].allSource
  archiveName = archiveBase + '-sources.jar'
  destinationDir = libsDir
}

task("${profile}JavadocJar", type: Jar, dependsOn: "${profile}Javadoc") {
  group 'Build'
  description "Assembles a jar archive containing the '${profile}' JavaDoc files."
  
  classifier = 'javadoc'
  from tasks["${profile}Javadoc"].destinationDir
  archiveName = archiveBase + '-javadoc.jar'
  destinationDir = libsDir
}

task testNG(type: Test) {
  useTestNG()
  reports.html.destination = file("${buildDir}/reports/testng")
}

test {
  dependsOn testNG
  reports.html.destination = file("${buildDir}/reports/junit")
}

signing {
  sign tasks["${profile}Jar"]
  sign tasks["${profile}SourcesJar"]
  sign tasks["${profile}JavadocJar"]
  sign pomCopy
}

uploadArchives {
  repositories {
    mavenDeployer {
      beforeDeployment {
        MavenDeployment deployment -> signing.signPom(deployment)
      }

      repository(url: 'https://oss.sonatype.org/service/local/staging/deploy/maven2/') {
        authentication(userName: ossrhUsername, password: ossrhPassword)
      }

      snapshotRepository(url: 'https://oss.sonatype.org/content/repositories/snapshots/') {
        authentication(userName: ossrhUsername, password: ossrhPassword)
      }

      pom.scopeMappings.with {
        mappings.clear()
        addMapping(300, configurations.compile, 'compile')
        addMapping(300, configurations["${profile}Compile"], 'compile')
      }
            
      pom.project {
        name 'Selenium Foundation'
        groupId project.group
        artifactId rootProject.name
        version archiveVer
        packaging 'jar'
        description 'Selenium Foundation is an automation framework designed to extend and enhance the capabilities provided by Selenium (WebDriver).'
        url 'https://github.com/Nordstrom/Selenium-Foundation'

        scm {
          connection 'scm:git:https://github.com/Nordstrom/Selenium-Foundation.git'
          developerConnection 'scm:git:https://github.com/Nordstrom/Selenium-Foundation.git'
          url 'https://github.com/Nordstrom/Selenium-Foundation/tree/master'
          tag 'HEAD'
        }

        licenses {
          license {
            name 'The Apache License, Version 2.0'
            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
          }
        }

        developers {
          developer {
            id 'scoba'
            name 'Scott Babcock'
            email 'scoba@hotmail.com'
            organization 'Nordstrom'
            organizationUrl 'https://shop.nordstrom.com'
          }
        }
      }
    }
  }
}

nexusStaging {
  packageGroup = 'com.nordstrom'
  stagingProfileId = '76d943f622957'
}

artifacts {
  archives tasks["${profile}Jar"]
  archives tasks["${profile}SourcesJar"]
  archives tasks["${profile}JavadocJar"]
  archives pomCopy
}

repositories {
   mavenLocal()
   mavenCentral()
   maven { url 'https://mvnrepo.nordstrom.net/nexus/content/repositories/thirdparty' }
   maven { url 'http://public-snapshots' }
   maven { url 'http://repo.maven.apache.org/maven2' }
}

dependencies {
  compile group: 'com.nordstrom.tools', name: 'java-utils', version:'1.3.3'
  compile group: 'com.nordstrom.tools', name: 'settings', version:'2.0.7'
  compile group: 'com.nordstrom.tools', name: 'testng-foundation', version:'1.6.0'
  compile group: 'com.nordstrom.tools', name: 'junit-foundation', version:'3.1.5'
  compile group: 'org.jboss.resteasy', name: 'resteasy-jaxrs', version:'3.1.2.Final'
  compile group: 'org.jboss.resteasy', name: 'resteasy-client', version:'3.1.2.Final'
  compile group: 'net.bytebuddy', name: 'byte-buddy', version:'1.7.9'
  compile group: 'ch.qos.logback', name: 'logback-classic', version:'1.2.2'
  compile group: 'com.github.sbabcoc', name: 'logback-testng', version:'1.0.0'
  
  selenium2Compile configurations.compile
  selenium2Compile group: 'org.seleniumhq.selenium', name: 'selenium-server-standalone', version:'2.53.0'
  selenium2Compile group: 'com.google.guava', name: 'guava', version: '21.0'
  
  selenium3Compile configurations.compile
  selenium3Compile group: 'org.seleniumhq.selenium', name: 'selenium-server-standalone', version:'3.8.1'
  selenium3Compile group: 'com.google.guava', name: 'guava', version: '23.5-jre'
  selenium3Compile group: 'com.codeborne', name: 'phantomjsdriver', version: '1.4.4'
  
  testCompile configurations["${profile}Compile"]
  testCompile group: 'org.mockito', name: 'mockito-all', version:'1.10.19'
}

class PomCopy extends Tar {

    public PomCopy() {
        getConventionMapping().map("extension", new Callable<Object>(){
            public Object call() throws Exception {
                return 'pom';
            }
        });
    }

    @Override
    protected CopyAction createCopyAction() {
        File destinationDir = getDestinationDir();
        if (destinationDir == null) {
            throw new InvalidUserDataException("No copy destination directory has been specified, use 'into' to specify a target directory.");
        }
        return new FileCopyAction(getFileLookup().getFileResolver(destinationDir));
    }

    @Override
    protected CopySpecInternal createRootSpec() {
        Instantiator instantiator = getInstantiator();
        FileResolver fileResolver = getFileResolver();

        return instantiator.newInstance(DestinationRootCopySpec.class, fileResolver, super.createRootSpec());
    }

    @Override
    public DestinationRootCopySpec getRootSpec() {
        return (DestinationRootCopySpec) super.getRootSpec();
    }

    /**
     * Returns the directory to copy files into.
     *
     * @return The destination dir.
     */
    @OutputDirectory
    public File getDestinationDir() {
        return getRootSpec().getDestinationDir();
    }

    /**
     * Sets the directory to copy files into. This is the same as calling {@link #into(Object)} on this task.
     *
     * @param destinationDir The destination directory. Must not be null.
     */
    public void setDestinationDir(File destinationDir) {
        into(destinationDir);
    }
  
}
